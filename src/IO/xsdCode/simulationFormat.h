// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

/**
 * @file
 * @brief Generated from simulationFormat.xsd.
 */

#ifndef CXX_________INPUT_SIMULATION_FORMAT_H
#define CXX_________INPUT_SIMULATION_FORMAT_H

#ifndef XSD_CXX11
#define XSD_CXX11
#endif

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

/**
 * @brief C++ namespace for the %http://www.w3.org/2001/XMLSchema
 * schema namespace.
 */
namespace xml_schema
{
  // anyType and anySimpleType.
  //

  /**
   * @brief C++ type corresponding to the anyType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::type type;

  /**
   * @brief C++ type corresponding to the anySimpleType XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;

  /**
   * @brief Alias for the anyType type.
   */
  typedef ::xsd::cxx::tree::type container;


  // 8-bit
  //

  /**
   * @brief C++ type corresponding to the byte XML Schema
   * built-in type.
   */
  typedef signed char byte;

  /**
   * @brief C++ type corresponding to the unsignedByte XML Schema
   * built-in type.
   */
  typedef unsigned char unsigned_byte;


  // 16-bit
  //

  /**
   * @brief C++ type corresponding to the short XML Schema
   * built-in type.
   */
  typedef short short_;

  /**
   * @brief C++ type corresponding to the unsignedShort XML Schema
   * built-in type.
   */
  typedef unsigned short unsigned_short;


  // 32-bit
  //

  /**
   * @brief C++ type corresponding to the int XML Schema
   * built-in type.
   */
  typedef int int_;

  /**
   * @brief C++ type corresponding to the unsignedInt XML Schema
   * built-in type.
   */
  typedef unsigned int unsigned_int;


  // 64-bit
  //

  /**
   * @brief C++ type corresponding to the long XML Schema
   * built-in type.
   */
  typedef long long long_;

  /**
   * @brief C++ type corresponding to the unsignedLong XML Schema
   * built-in type.
   */
  typedef unsigned long long unsigned_long;


  // Supposed to be arbitrary-length integral types.
  //

  /**
   * @brief C++ type corresponding to the integer XML Schema
   * built-in type.
   */
  typedef long long integer;

  /**
   * @brief C++ type corresponding to the nonPositiveInteger XML Schema
   * built-in type.
   */
  typedef long long non_positive_integer;

  /**
   * @brief C++ type corresponding to the nonNegativeInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long non_negative_integer;

  /**
   * @brief C++ type corresponding to the positiveInteger XML Schema
   * built-in type.
   */
  typedef unsigned long long positive_integer;

  /**
   * @brief C++ type corresponding to the negativeInteger XML Schema
   * built-in type.
   */
  typedef long long negative_integer;


  // Boolean.
  //

  /**
   * @brief C++ type corresponding to the boolean XML Schema
   * built-in type.
   */
  typedef bool boolean;


  // Floating-point types.
  //

  /**
   * @brief C++ type corresponding to the float XML Schema
   * built-in type.
   */
  typedef float float_;

  /**
   * @brief C++ type corresponding to the double XML Schema
   * built-in type.
   */
  typedef double double_;

  /**
   * @brief C++ type corresponding to the decimal XML Schema
   * built-in type.
   */
  typedef double decimal;


  // String types.
  //

  /**
   * @brief C++ type corresponding to the string XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::string< char, simple_type > string;

  /**
   * @brief C++ type corresponding to the normalizedString XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;

  /**
   * @brief C++ type corresponding to the token XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;

  /**
   * @brief C++ type corresponding to the Name XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::name< char, token > name;

  /**
   * @brief C++ type corresponding to the NMTOKEN XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;

  /**
   * @brief C++ type corresponding to the NMTOKENS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;

  /**
   * @brief C++ type corresponding to the NCName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;

  /**
   * @brief C++ type corresponding to the language XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::language< char, token > language;


  // ID/IDREF.
  //

  /**
   * @brief C++ type corresponding to the ID XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::id< char, ncname > id;

  /**
   * @brief C++ type corresponding to the IDREF XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;

  /**
   * @brief C++ type corresponding to the IDREFS XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;


  // URI.
  //

  /**
   * @brief C++ type corresponding to the anyURI XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;


  // Qualified name.
  //

  /**
   * @brief C++ type corresponding to the QName XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;


  // Binary.
  //

  /**
   * @brief Binary buffer type.
   */
  typedef ::xsd::cxx::tree::buffer< char > buffer;

  /**
   * @brief C++ type corresponding to the base64Binary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;

  /**
   * @brief C++ type corresponding to the hexBinary XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;


  // Date/time.
  //

  /**
   * @brief Time zone type.
   */
  typedef ::xsd::cxx::tree::time_zone time_zone;

  /**
   * @brief C++ type corresponding to the date XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date< char, simple_type > date;

  /**
   * @brief C++ type corresponding to the dateTime XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;

  /**
   * @brief C++ type corresponding to the duration XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;

  /**
   * @brief C++ type corresponding to the gDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;

  /**
   * @brief C++ type corresponding to the gMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;

  /**
   * @brief C++ type corresponding to the gMonthDay XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;

  /**
   * @brief C++ type corresponding to the gYear XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;

  /**
   * @brief C++ type corresponding to the gYearMonth XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;

  /**
   * @brief C++ type corresponding to the time XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::time< char, simple_type > time;


  // Entity.
  //

  /**
   * @brief C++ type corresponding to the ENTITY XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;

  /**
   * @brief C++ type corresponding to the ENTITIES XML Schema
   * built-in type.
   */
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;



  /**
   * @brief Content order sequence entry.
   */
  typedef ::xsd::cxx::tree::content_order content_order;
  // Flags and properties.
  //

  /**
   * @brief Parsing and serialization flags.
   */
  typedef ::xsd::cxx::tree::flags flags;

  /**
   * @brief Parsing properties.
   */
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //

  /**
   * @brief Error severity.
   */
  typedef ::xsd::cxx::tree::severity severity;

  /**
   * @brief Error condition.
   */
  typedef ::xsd::cxx::tree::error< char > error;

  /**
   * @brief List of %error conditions.
   */
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //

  /**
   * @brief Root of the C++/Tree %exception hierarchy.
   */
  typedef ::xsd::cxx::tree::exception< char > exception;

  /**
   * @brief Exception indicating that the size argument exceeds
   * the capacity argument.
   */
  typedef ::xsd::cxx::tree::bounds< char > bounds;

  /**
   * @brief Exception indicating that a duplicate ID value
   * was encountered in the object model.
   */
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;

  /**
   * @brief Exception indicating a parsing failure.
   */
  typedef ::xsd::cxx::tree::parsing< char > parsing;

  /**
   * @brief Exception indicating that an expected element
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;

  /**
   * @brief Exception indicating that an unexpected element
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;

  /**
   * @brief Exception indicating that an expected attribute
   * was not encountered.
   */
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;

  /**
   * @brief Exception indicating that an unexpected enumerator
   * was encountered.
   */
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;

  /**
   * @brief Exception indicating that the text content was
   * expected for an element.
   */
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;

  /**
   * @brief Exception indicating that a prefix-namespace
   * mapping was not provided.
   */
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;

  /**
   * @brief Error handler callback interface.
   */
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  /**
   * @brief DOM interaction.
   */
  namespace dom
  {
    /**
     * @brief Automatic pointer for DOMDocument.
     */
    using ::xsd::cxx::xml::dom::unique_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    /**
     * @brief DOM user data key for back pointers to tree nodes.
     */
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class log_level;
class Dimension;
class lennardJones_t;
class gravity_t;
class ForceType;
class simpleThermostatType;
class gradualThermostatType;
class tempDiffThermostatType;
class ThermostatType;
class Cuboid;
class Membrane;
class Sphere;
class BoundaryBehavior;
class Boundaries;
class ParallelizationSpecXML;
class Simulation_t;
class hardcoded_force;
class force_factors;
class particles;
class indices;

#include <memory>    // ::std::unique_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search
#include <utility>   // std::move

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "commonSchema.h"

/**
 * @brief Class corresponding to the %log_level schema type.
 *
 * @nosubgrouping
 */
class log_level: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
{
  public:
  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  log_level (const ::xml_schema::integer&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  log_level (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  log_level (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  log_level (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  log_level (const log_level& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual log_level*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~log_level ();
};

/**
 * @brief Enumeration class corresponding to the %Dimension
 * schema type.
 */
class Dimension: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    cxx_2D,
    cxx_3D
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  Dimension (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  Dimension (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  Dimension (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  Dimension (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Dimension (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Dimension (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Dimension (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Dimension (const Dimension& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Dimension*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  Dimension&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_Dimension_convert ();
  }

  //@cond

  protected:
  value
  _xsd_Dimension_convert () const;

  public:
  static const char* const _xsd_Dimension_literals_[2];
  static const value _xsd_Dimension_indexes_[2];

  //@endcond
};

/**
 * @brief Class corresponding to the %lennardJones_t schema type.
 *
 * @nosubgrouping
 */
class lennardJones_t: public ::xml_schema::type
{
  public:
  /**
   * @name Epsilon
   *
   * @brief Accessor and modifier functions for the %Epsilon
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ Epsilon_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Epsilon_type, char, ::xsd::cxx::tree::schema_type::double_ > Epsilon_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Epsilon_type&
  Epsilon () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Epsilon_type&
  Epsilon ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Epsilon (const Epsilon_type& x);

  //@}

  /**
   * @name Sigma
   *
   * @brief Accessor and modifier functions for the %Sigma
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ Sigma_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Sigma_type, char, ::xsd::cxx::tree::schema_type::double_ > Sigma_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Sigma_type&
  Sigma () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Sigma_type&
  Sigma ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Sigma (const Sigma_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  lennardJones_t (const Epsilon_type&,
                  const Sigma_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  lennardJones_t (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  lennardJones_t (const lennardJones_t& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual lennardJones_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  lennardJones_t&
  operator= (const lennardJones_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~lennardJones_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Epsilon_type > Epsilon_;
  ::xsd::cxx::tree::one< Sigma_type > Sigma_;

  //@endcond
};

/**
 * @brief Class corresponding to the %gravity_t schema type.
 *
 * @nosubgrouping
 */
class gravity_t: public ::xml_schema::type
{
  public:
  /**
   * @name gravity_factor
   *
   * @brief Accessor and modifier functions for the %gravity_factor
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::double_3d gravity_factor_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< gravity_factor_type, char > gravity_factor_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const gravity_factor_type&
  gravity_factor () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  gravity_factor_type&
  gravity_factor ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  gravity_factor (const gravity_factor_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  gravity_factor (::std::unique_ptr< gravity_factor_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  gravity_t (const gravity_factor_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  gravity_t (::std::unique_ptr< gravity_factor_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  gravity_t (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  gravity_t (const gravity_t& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual gravity_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  gravity_t&
  operator= (const gravity_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~gravity_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< gravity_factor_type > gravity_factor_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ForceType schema type.
 *
 * @nosubgrouping
 */
class ForceType: public ::xml_schema::type
{
  public:
  /**
   * @name lennard
   *
   * @brief Accessor and modifier functions for the %lennard
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::lennardJones_t lennard_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< lennard_type > lennard_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< lennard_type, char > lennard_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const lennard_optional&
  lennard () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  lennard_optional&
  lennard ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  lennard (const lennard_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  lennard (const lennard_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  lennard (::std::unique_ptr< lennard_type > p);

  //@}

  /**
   * @name grav
   *
   * @brief Accessor and modifier functions for the %grav
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string grav_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< grav_type > grav_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< grav_type, char > grav_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const grav_optional&
  grav () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  grav_optional&
  grav ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  grav (const grav_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  grav (const grav_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  grav (::std::unique_ptr< grav_type > p);

  //@}

  /**
   * @name MixingRuleLennardJones
   *
   * @brief Accessor and modifier functions for the %MixingRuleLennardJones
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string MixingRuleLennardJones_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< MixingRuleLennardJones_type > MixingRuleLennardJones_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< MixingRuleLennardJones_type, char > MixingRuleLennardJones_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const MixingRuleLennardJones_optional&
  MixingRuleLennardJones () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  MixingRuleLennardJones_optional&
  MixingRuleLennardJones ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  MixingRuleLennardJones (const MixingRuleLennardJones_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  MixingRuleLennardJones (const MixingRuleLennardJones_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  MixingRuleLennardJones (::std::unique_ptr< MixingRuleLennardJones_type > p);

  //@}

  /**
   * @name TruncatedLennardJones
   *
   * @brief Accessor and modifier functions for the %TruncatedLennardJones
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string TruncatedLennardJones_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< TruncatedLennardJones_type > TruncatedLennardJones_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< TruncatedLennardJones_type, char > TruncatedLennardJones_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const TruncatedLennardJones_optional&
  TruncatedLennardJones () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  TruncatedLennardJones_optional&
  TruncatedLennardJones ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  TruncatedLennardJones (const TruncatedLennardJones_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  TruncatedLennardJones (const TruncatedLennardJones_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  TruncatedLennardJones (::std::unique_ptr< TruncatedLennardJones_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ForceType ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ForceType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ForceType (const ForceType& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ForceType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ForceType&
  operator= (const ForceType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ForceType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  lennard_optional lennard_;
  grav_optional grav_;
  MixingRuleLennardJones_optional MixingRuleLennardJones_;
  TruncatedLennardJones_optional TruncatedLennardJones_;

  //@endcond
};

/**
 * @brief Class corresponding to the %simpleThermostatType schema type.
 *
 * @nosubgrouping
 */
class simpleThermostatType: public ::xml_schema::type
{
  public:
  /**
   * @name initTemperature
   *
   * @brief Accessor and modifier functions for the %initTemperature
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble initTemperature_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< initTemperature_type, char > initTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const initTemperature_type&
  initTemperature () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  initTemperature_type&
  initTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  initTemperature (const initTemperature_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  initTemperature (::std::unique_ptr< initTemperature_type > p);

  //@}

  /**
   * @name targetTemperature
   *
   * @brief Accessor and modifier functions for the %targetTemperature
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble targetTemperature_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< targetTemperature_type, char > targetTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const targetTemperature_type&
  targetTemperature () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  targetTemperature_type&
  targetTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  targetTemperature (const targetTemperature_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  targetTemperature (::std::unique_ptr< targetTemperature_type > p);

  //@}

  /**
   * @name thermostatCycleLength
   *
   * @brief Accessor and modifier functions for the %thermostatCycleLength
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeInteger thermostatCycleLength_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< thermostatCycleLength_type, char > thermostatCycleLength_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const thermostatCycleLength_type&
  thermostatCycleLength () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  thermostatCycleLength_type&
  thermostatCycleLength ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  thermostatCycleLength (const thermostatCycleLength_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  thermostatCycleLength (::std::unique_ptr< thermostatCycleLength_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  simpleThermostatType (const initTemperature_type&,
                        const targetTemperature_type&,
                        const thermostatCycleLength_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  simpleThermostatType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  simpleThermostatType (const simpleThermostatType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual simpleThermostatType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  simpleThermostatType&
  operator= (const simpleThermostatType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~simpleThermostatType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< initTemperature_type > initTemperature_;
  ::xsd::cxx::tree::one< targetTemperature_type > targetTemperature_;
  ::xsd::cxx::tree::one< thermostatCycleLength_type > thermostatCycleLength_;

  //@endcond
};

/**
 * @brief Class corresponding to the %gradualThermostatType schema type.
 *
 * @nosubgrouping
 */
class gradualThermostatType: public ::xml_schema::type
{
  public:
  /**
   * @name initTemperature
   *
   * @brief Accessor and modifier functions for the %initTemperature
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble initTemperature_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< initTemperature_type, char > initTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const initTemperature_type&
  initTemperature () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  initTemperature_type&
  initTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  initTemperature (const initTemperature_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  initTemperature (::std::unique_ptr< initTemperature_type > p);

  //@}

  /**
   * @name targetTemperature
   *
   * @brief Accessor and modifier functions for the %targetTemperature
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble targetTemperature_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< targetTemperature_type, char > targetTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const targetTemperature_type&
  targetTemperature () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  targetTemperature_type&
  targetTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  targetTemperature (const targetTemperature_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  targetTemperature (::std::unique_ptr< targetTemperature_type > p);

  //@}

  /**
   * @name maxTemperatureChange
   *
   * @brief Accessor and modifier functions for the %maxTemperatureChange
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble maxTemperatureChange_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< maxTemperatureChange_type, char > maxTemperatureChange_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const maxTemperatureChange_type&
  maxTemperatureChange () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  maxTemperatureChange_type&
  maxTemperatureChange ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  maxTemperatureChange (const maxTemperatureChange_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  maxTemperatureChange (::std::unique_ptr< maxTemperatureChange_type > p);

  //@}

  /**
   * @name thermostatCycleLength
   *
   * @brief Accessor and modifier functions for the %thermostatCycleLength
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeInteger thermostatCycleLength_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< thermostatCycleLength_type, char > thermostatCycleLength_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const thermostatCycleLength_type&
  thermostatCycleLength () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  thermostatCycleLength_type&
  thermostatCycleLength ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  thermostatCycleLength (const thermostatCycleLength_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  thermostatCycleLength (::std::unique_ptr< thermostatCycleLength_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  gradualThermostatType (const initTemperature_type&,
                         const targetTemperature_type&,
                         const maxTemperatureChange_type&,
                         const thermostatCycleLength_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  gradualThermostatType (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  gradualThermostatType (const gradualThermostatType& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual gradualThermostatType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  gradualThermostatType&
  operator= (const gradualThermostatType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~gradualThermostatType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< initTemperature_type > initTemperature_;
  ::xsd::cxx::tree::one< targetTemperature_type > targetTemperature_;
  ::xsd::cxx::tree::one< maxTemperatureChange_type > maxTemperatureChange_;
  ::xsd::cxx::tree::one< thermostatCycleLength_type > thermostatCycleLength_;

  //@endcond
};

/**
 * @brief Class corresponding to the %tempDiffThermostatType schema type.
 *
 * @nosubgrouping
 */
class tempDiffThermostatType: public ::xml_schema::type
{
  public:
  /**
   * @name initTemperature
   *
   * @brief Accessor and modifier functions for the %initTemperature
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble initTemperature_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< initTemperature_type, char > initTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const initTemperature_type&
  initTemperature () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  initTemperature_type&
  initTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  initTemperature (const initTemperature_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  initTemperature (::std::unique_ptr< initTemperature_type > p);

  //@}

  /**
   * @name targetTemperature
   *
   * @brief Accessor and modifier functions for the %targetTemperature
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble targetTemperature_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< targetTemperature_type, char > targetTemperature_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const targetTemperature_type&
  targetTemperature () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  targetTemperature_type&
  targetTemperature ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  targetTemperature (const targetTemperature_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  targetTemperature (::std::unique_ptr< targetTemperature_type > p);

  //@}

  /**
   * @name thermostatCycleLength
   *
   * @brief Accessor and modifier functions for the %thermostatCycleLength
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeInteger thermostatCycleLength_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< thermostatCycleLength_type, char > thermostatCycleLength_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const thermostatCycleLength_type&
  thermostatCycleLength () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  thermostatCycleLength_type&
  thermostatCycleLength ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  thermostatCycleLength (const thermostatCycleLength_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  thermostatCycleLength (::std::unique_ptr< thermostatCycleLength_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  tempDiffThermostatType (const initTemperature_type&,
                          const targetTemperature_type&,
                          const thermostatCycleLength_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  tempDiffThermostatType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tempDiffThermostatType (const tempDiffThermostatType& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual tempDiffThermostatType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  tempDiffThermostatType&
  operator= (const tempDiffThermostatType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~tempDiffThermostatType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< initTemperature_type > initTemperature_;
  ::xsd::cxx::tree::one< targetTemperature_type > targetTemperature_;
  ::xsd::cxx::tree::one< thermostatCycleLength_type > thermostatCycleLength_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ThermostatType schema type.
 *
 * @nosubgrouping
 */
class ThermostatType: public ::xml_schema::type
{
  public:
  /**
   * @name none
   *
   * @brief Accessor and modifier functions for the %none
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string none_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< none_type > none_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< none_type, char > none_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const none_optional&
  none () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  none_optional&
  none ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  none (const none_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  none (const none_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  none (::std::unique_ptr< none_type > p);

  //@}

  /**
   * @name simple
   *
   * @brief Accessor and modifier functions for the %simple
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::simpleThermostatType simple_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< simple_type > simple_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< simple_type, char > simple_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const simple_optional&
  simple () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  simple_optional&
  simple ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  simple (const simple_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  simple (const simple_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  simple (::std::unique_ptr< simple_type > p);

  //@}

  /**
   * @name gradual
   *
   * @brief Accessor and modifier functions for the %gradual
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::gradualThermostatType gradual_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< gradual_type > gradual_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< gradual_type, char > gradual_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const gradual_optional&
  gradual () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  gradual_optional&
  gradual ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  gradual (const gradual_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  gradual (const gradual_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  gradual (::std::unique_ptr< gradual_type > p);

  //@}

  /**
   * @name tempDiff
   *
   * @brief Accessor and modifier functions for the %tempDiff
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::tempDiffThermostatType tempDiff_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< tempDiff_type > tempDiff_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< tempDiff_type, char > tempDiff_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const tempDiff_optional&
  tempDiff () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  tempDiff_optional&
  tempDiff ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  tempDiff (const tempDiff_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  tempDiff (const tempDiff_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  tempDiff (::std::unique_ptr< tempDiff_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ThermostatType ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ThermostatType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ThermostatType (const ThermostatType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ThermostatType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ThermostatType&
  operator= (const ThermostatType& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ThermostatType ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  none_optional none_;
  simple_optional simple_;
  gradual_optional gradual_;
  tempDiff_optional tempDiff_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Cuboid schema type.
 *
 * @nosubgrouping
 */
class Cuboid: public ::xml_schema::type
{
  public:
  /**
   * @name lower-left-coord
   *
   * @brief Accessor and modifier functions for the %lower-left-coord
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::double_3d lower_left_coord_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< lower_left_coord_type, char > lower_left_coord_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const lower_left_coord_type&
  lower_left_coord () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  lower_left_coord_type&
  lower_left_coord ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  lower_left_coord (const lower_left_coord_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  lower_left_coord (::std::unique_ptr< lower_left_coord_type > p);

  //@}

  /**
   * @name number-of-particles
   *
   * @brief Accessor and modifier functions for the %number-of-particles
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::int_3d number_of_particles_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< number_of_particles_type, char > number_of_particles_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const number_of_particles_type&
  number_of_particles () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  number_of_particles_type&
  number_of_particles ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  number_of_particles (const number_of_particles_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  number_of_particles (::std::unique_ptr< number_of_particles_type > p);

  //@}

  /**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble distance_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< distance_type, char > distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const distance_type&
  distance () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  distance_type&
  distance ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  distance (const distance_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  distance (::std::unique_ptr< distance_type > p);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< mass_type, char > mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const mass_type&
  mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  mass_type&
  mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  mass (const mass_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  mass (::std::unique_ptr< mass_type > p);

  //@}

  /**
   * @name initial_velocity
   *
   * @brief Accessor and modifier functions for the %initial_velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::double_3d initial_velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< initial_velocity_type, char > initial_velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const initial_velocity_type&
  initial_velocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  initial_velocity_type&
  initial_velocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  initial_velocity (const initial_velocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  initial_velocity (::std::unique_ptr< initial_velocity_type > p);

  //@}

  /**
   * @name epsilon_cuboid
   *
   * @brief Accessor and modifier functions for the %epsilon_cuboid
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble epsilon_cuboid_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< epsilon_cuboid_type > epsilon_cuboid_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< epsilon_cuboid_type, char > epsilon_cuboid_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const epsilon_cuboid_optional&
  epsilon_cuboid () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  epsilon_cuboid_optional&
  epsilon_cuboid ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  epsilon_cuboid (const epsilon_cuboid_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  epsilon_cuboid (const epsilon_cuboid_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  epsilon_cuboid (::std::unique_ptr< epsilon_cuboid_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static epsilon_cuboid_type
  epsilon_cuboid_default_value ();

  //@}

  /**
   * @name sigma_cuboid
   *
   * @brief Accessor and modifier functions for the %sigma_cuboid
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble sigma_cuboid_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< sigma_cuboid_type > sigma_cuboid_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sigma_cuboid_type, char > sigma_cuboid_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sigma_cuboid_optional&
  sigma_cuboid () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  sigma_cuboid_optional&
  sigma_cuboid ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  sigma_cuboid (const sigma_cuboid_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  sigma_cuboid (const sigma_cuboid_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  sigma_cuboid (::std::unique_ptr< sigma_cuboid_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static sigma_cuboid_type
  sigma_cuboid_default_value ();

  //@}

  /**
   * @name wall
   *
   * @brief Accessor and modifier functions for the %wall
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean wall_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< wall_type > wall_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< wall_type, char > wall_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const wall_optional&
  wall () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  wall_optional&
  wall ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  wall (const wall_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  wall (const wall_optional& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static wall_type
  wall_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Cuboid (const lower_left_coord_type&,
          const number_of_particles_type&,
          const distance_type&,
          const mass_type&,
          const initial_velocity_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Cuboid (::std::unique_ptr< lower_left_coord_type >,
          ::std::unique_ptr< number_of_particles_type >,
          const distance_type&,
          const mass_type&,
          ::std::unique_ptr< initial_velocity_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Cuboid (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Cuboid (const Cuboid& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Cuboid*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Cuboid&
  operator= (const Cuboid& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Cuboid ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< lower_left_coord_type > lower_left_coord_;
  ::xsd::cxx::tree::one< number_of_particles_type > number_of_particles_;
  ::xsd::cxx::tree::one< distance_type > distance_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< initial_velocity_type > initial_velocity_;
  epsilon_cuboid_optional epsilon_cuboid_;
  sigma_cuboid_optional sigma_cuboid_;
  wall_optional wall_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Membrane schema type.
 *
 * @nosubgrouping
 */
class Membrane: public ::xml_schema::type
{
  public:
  /**
   * @name lower-left-coord
   *
   * @brief Accessor and modifier functions for the %lower-left-coord
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::double_3d lower_left_coord_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< lower_left_coord_type, char > lower_left_coord_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const lower_left_coord_type&
  lower_left_coord () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  lower_left_coord_type&
  lower_left_coord ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  lower_left_coord (const lower_left_coord_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  lower_left_coord (::std::unique_ptr< lower_left_coord_type > p);

  //@}

  /**
   * @name number-of-particles
   *
   * @brief Accessor and modifier functions for the %number-of-particles
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::int_3d number_of_particles_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< number_of_particles_type, char > number_of_particles_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const number_of_particles_type&
  number_of_particles () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  number_of_particles_type&
  number_of_particles ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  number_of_particles (const number_of_particles_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  number_of_particles (::std::unique_ptr< number_of_particles_type > p);

  //@}

  /**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble distance_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< distance_type, char > distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const distance_type&
  distance () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  distance_type&
  distance ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  distance (const distance_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  distance (::std::unique_ptr< distance_type > p);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< mass_type, char > mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const mass_type&
  mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  mass_type&
  mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  mass (const mass_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  mass (::std::unique_ptr< mass_type > p);

  //@}

  /**
   * @name initial_velocity
   *
   * @brief Accessor and modifier functions for the %initial_velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::double_3d initial_velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< initial_velocity_type, char > initial_velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const initial_velocity_type&
  initial_velocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  initial_velocity_type&
  initial_velocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  initial_velocity (const initial_velocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  initial_velocity (::std::unique_ptr< initial_velocity_type > p);

  //@}

  /**
   * @name epsilon_cuboid
   *
   * @brief Accessor and modifier functions for the %epsilon_cuboid
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble epsilon_cuboid_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< epsilon_cuboid_type > epsilon_cuboid_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< epsilon_cuboid_type, char > epsilon_cuboid_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const epsilon_cuboid_optional&
  epsilon_cuboid () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  epsilon_cuboid_optional&
  epsilon_cuboid ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  epsilon_cuboid (const epsilon_cuboid_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  epsilon_cuboid (const epsilon_cuboid_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  epsilon_cuboid (::std::unique_ptr< epsilon_cuboid_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static epsilon_cuboid_type
  epsilon_cuboid_default_value ();

  //@}

  /**
   * @name sigma_cuboid
   *
   * @brief Accessor and modifier functions for the %sigma_cuboid
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble sigma_cuboid_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< sigma_cuboid_type > sigma_cuboid_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sigma_cuboid_type, char > sigma_cuboid_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sigma_cuboid_optional&
  sigma_cuboid () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  sigma_cuboid_optional&
  sigma_cuboid ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  sigma_cuboid (const sigma_cuboid_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  sigma_cuboid (const sigma_cuboid_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  sigma_cuboid (::std::unique_ptr< sigma_cuboid_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static sigma_cuboid_type
  sigma_cuboid_default_value ();

  //@}

  /**
   * @name stiffness
   *
   * @brief Accessor and modifier functions for the %stiffness
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble stiffness_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< stiffness_type, char > stiffness_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const stiffness_type&
  stiffness () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  stiffness_type&
  stiffness ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  stiffness (const stiffness_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  stiffness (::std::unique_ptr< stiffness_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static stiffness_type
  stiffness_default_value ();

  //@}

  /**
   * @name bond_length
   *
   * @brief Accessor and modifier functions for the %bond_length
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble bond_length_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< bond_length_type, char > bond_length_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const bond_length_type&
  bond_length () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  bond_length_type&
  bond_length ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  bond_length (const bond_length_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  bond_length (::std::unique_ptr< bond_length_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static bond_length_type
  bond_length_default_value ();

  //@}

  /**
   * @name hardcoded_force
   *
   * @brief Accessor and modifier functions for the %hardcoded_force
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::hardcoded_force hardcoded_force_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< hardcoded_force_type > hardcoded_force_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef hardcoded_force_sequence::iterator hardcoded_force_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef hardcoded_force_sequence::const_iterator hardcoded_force_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< hardcoded_force_type, char > hardcoded_force_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const hardcoded_force_sequence&
  hardcoded_force () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  hardcoded_force_sequence&
  hardcoded_force ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  hardcoded_force (const hardcoded_force_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Membrane (const lower_left_coord_type&,
            const number_of_particles_type&,
            const distance_type&,
            const mass_type&,
            const initial_velocity_type&,
            const stiffness_type&,
            const bond_length_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Membrane (::std::unique_ptr< lower_left_coord_type >,
            ::std::unique_ptr< number_of_particles_type >,
            const distance_type&,
            const mass_type&,
            ::std::unique_ptr< initial_velocity_type >,
            const stiffness_type&,
            const bond_length_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Membrane (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Membrane (const Membrane& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Membrane*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Membrane&
  operator= (const Membrane& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Membrane ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< lower_left_coord_type > lower_left_coord_;
  ::xsd::cxx::tree::one< number_of_particles_type > number_of_particles_;
  ::xsd::cxx::tree::one< distance_type > distance_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< initial_velocity_type > initial_velocity_;
  epsilon_cuboid_optional epsilon_cuboid_;
  sigma_cuboid_optional sigma_cuboid_;
  ::xsd::cxx::tree::one< stiffness_type > stiffness_;
  ::xsd::cxx::tree::one< bond_length_type > bond_length_;
  hardcoded_force_sequence hardcoded_force_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Sphere schema type.
 *
 * @nosubgrouping
 */
class Sphere: public ::xml_schema::type
{
  public:
  /**
   * @name dimension
   *
   * @brief Accessor and modifier functions for the %dimension
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Dimension dimension_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const dimension_type&
  dimension () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  dimension_type&
  dimension ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  dimension (const dimension_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  dimension (::std::unique_ptr< dimension_type > p);

  //@}

  /**
   * @name center
   *
   * @brief Accessor and modifier functions for the %center
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::double_3d center_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< center_type, char > center_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const center_type&
  center () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  center_type&
  center ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  center (const center_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  center (::std::unique_ptr< center_type > p);

  //@}

  /**
   * @name radius
   *
   * @brief Accessor and modifier functions for the %radius
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeInteger radius_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< radius_type, char > radius_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const radius_type&
  radius () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  radius_type&
  radius ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  radius (const radius_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  radius (::std::unique_ptr< radius_type > p);

  //@}

  /**
   * @name distance
   *
   * @brief Accessor and modifier functions for the %distance
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble distance_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< distance_type, char > distance_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const distance_type&
  distance () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  distance_type&
  distance ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  distance (const distance_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  distance (::std::unique_ptr< distance_type > p);

  //@}

  /**
   * @name mass
   *
   * @brief Accessor and modifier functions for the %mass
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble mass_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< mass_type, char > mass_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const mass_type&
  mass () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  mass_type&
  mass ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  mass (const mass_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  mass (::std::unique_ptr< mass_type > p);

  //@}

  /**
   * @name initial_velocity
   *
   * @brief Accessor and modifier functions for the %initial_velocity
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::double_3d initial_velocity_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< initial_velocity_type, char > initial_velocity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const initial_velocity_type&
  initial_velocity () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  initial_velocity_type&
  initial_velocity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  initial_velocity (const initial_velocity_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  initial_velocity (::std::unique_ptr< initial_velocity_type > p);

  //@}

  /**
   * @name epsilon_sphere
   *
   * @brief Accessor and modifier functions for the %epsilon_sphere
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble epsilon_sphere_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< epsilon_sphere_type > epsilon_sphere_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< epsilon_sphere_type, char > epsilon_sphere_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const epsilon_sphere_optional&
  epsilon_sphere () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  epsilon_sphere_optional&
  epsilon_sphere ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  epsilon_sphere (const epsilon_sphere_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  epsilon_sphere (const epsilon_sphere_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  epsilon_sphere (::std::unique_ptr< epsilon_sphere_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static epsilon_sphere_type
  epsilon_sphere_default_value ();

  //@}

  /**
   * @name sigma_sphere
   *
   * @brief Accessor and modifier functions for the %sigma_sphere
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble sigma_sphere_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< sigma_sphere_type > sigma_sphere_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sigma_sphere_type, char > sigma_sphere_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const sigma_sphere_optional&
  sigma_sphere () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  sigma_sphere_optional&
  sigma_sphere ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  sigma_sphere (const sigma_sphere_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  sigma_sphere (const sigma_sphere_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  sigma_sphere (::std::unique_ptr< sigma_sphere_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static sigma_sphere_type
  sigma_sphere_default_value ();

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Sphere (const dimension_type&,
          const center_type&,
          const radius_type&,
          const distance_type&,
          const mass_type&,
          const initial_velocity_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Sphere (const dimension_type&,
          ::std::unique_ptr< center_type >,
          const radius_type&,
          const distance_type&,
          const mass_type&,
          ::std::unique_ptr< initial_velocity_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Sphere (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Sphere (const Sphere& x,
          ::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Sphere*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Sphere&
  operator= (const Sphere& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Sphere ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< dimension_type > dimension_;
  ::xsd::cxx::tree::one< center_type > center_;
  ::xsd::cxx::tree::one< radius_type > radius_;
  ::xsd::cxx::tree::one< distance_type > distance_;
  ::xsd::cxx::tree::one< mass_type > mass_;
  ::xsd::cxx::tree::one< initial_velocity_type > initial_velocity_;
  epsilon_sphere_optional epsilon_sphere_;
  sigma_sphere_optional sigma_sphere_;

  //@endcond
};

/**
 * @brief Enumeration class corresponding to the %BoundaryBehavior
 * schema type.
 */
class BoundaryBehavior: public ::xml_schema::string
{
  public:

  /**
   * @brief Underlying enum type.
   */
  enum value
  {
    Outflow,
    Reflecting,
    Periodic
  };

  /**
   * @brief Create an instance from the underlying enum value.
   *
   * @param v A enum value.
   */
  BoundaryBehavior (value v);

  /**
   * @brief Create an instance from a C string.
   *
   * @param v A string value.
   */
  BoundaryBehavior (const char* v);

  /**
   * @brief Create an instance from a string.
   *
   * @param v A string value.
   */
  BoundaryBehavior (const ::std::string& v);

  /**
   * @brief Create an instance from the base value.
   *
   * @param v A base value.
   */
  BoundaryBehavior (const ::xml_schema::string& v);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  BoundaryBehavior (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a DOM attribute.
   *
   * @param a A DOM attribute to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  BoundaryBehavior (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Create an instance from a string fragment.
   *
   * @param s A string fragment to extract the data from.
   * @param e A pointer to DOM element containing the string fragment.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  BoundaryBehavior (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  BoundaryBehavior (const BoundaryBehavior& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual BoundaryBehavior*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Assign the underlying enum value.
   *
   * @param v A enum value.
   * @return A refernce to the instance.
   */
  BoundaryBehavior&
  operator= (value v);

  /**
   * @brief Implicit conversion operator to the underlying
   * enum value.
   *
   * @return A enum value.
   */
  virtual
  operator value () const
  {
    return _xsd_BoundaryBehavior_convert ();
  }

  //@cond

  protected:
  value
  _xsd_BoundaryBehavior_convert () const;

  public:
  static const char* const _xsd_BoundaryBehavior_literals_[3];
  static const value _xsd_BoundaryBehavior_indexes_[3];

  //@endcond
};

/**
 * @brief Class corresponding to the %Boundaries schema type.
 *
 * @nosubgrouping
 */
class Boundaries: public ::xml_schema::type
{
  public:
  /**
   * @name BoxSize
   *
   * @brief Accessor and modifier functions for the %BoxSize
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::double_3d BoxSize_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< BoxSize_type, char > BoxSize_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const BoxSize_type&
  BoxSize () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  BoxSize_type&
  BoxSize ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  BoxSize (const BoxSize_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  BoxSize (::std::unique_ptr< BoxSize_type > p);

  //@}

  /**
   * @name Front
   *
   * @brief Accessor and modifier functions for the %Front
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BoundaryBehavior Front_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Front_type, char > Front_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Front_type&
  Front () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Front_type&
  Front ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Front (const Front_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Front (::std::unique_ptr< Front_type > p);

  //@}

  /**
   * @name Back
   *
   * @brief Accessor and modifier functions for the %Back
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BoundaryBehavior Back_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Back_type, char > Back_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Back_type&
  Back () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Back_type&
  Back ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Back (const Back_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Back (::std::unique_ptr< Back_type > p);

  //@}

  /**
   * @name Top
   *
   * @brief Accessor and modifier functions for the %Top
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BoundaryBehavior Top_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Top_type, char > Top_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Top_type&
  Top () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Top_type&
  Top ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Top (const Top_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Top (::std::unique_ptr< Top_type > p);

  //@}

  /**
   * @name Right
   *
   * @brief Accessor and modifier functions for the %Right
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BoundaryBehavior Right_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Right_type, char > Right_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Right_type&
  Right () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Right_type&
  Right ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Right (const Right_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Right (::std::unique_ptr< Right_type > p);

  //@}

  /**
   * @name Bottom
   *
   * @brief Accessor and modifier functions for the %Bottom
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BoundaryBehavior Bottom_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Bottom_type, char > Bottom_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Bottom_type&
  Bottom () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Bottom_type&
  Bottom ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Bottom (const Bottom_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Bottom (::std::unique_ptr< Bottom_type > p);

  //@}

  /**
   * @name Left
   *
   * @brief Accessor and modifier functions for the %Left
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::BoundaryBehavior Left_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< Left_type, char > Left_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const Left_type&
  Left () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  Left_type&
  Left ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  Left (const Left_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  Left (::std::unique_ptr< Left_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Boundaries (const BoxSize_type&,
              const Front_type&,
              const Back_type&,
              const Top_type&,
              const Right_type&,
              const Bottom_type&,
              const Left_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  Boundaries (::std::unique_ptr< BoxSize_type >,
              const Front_type&,
              const Back_type&,
              const Top_type&,
              const Right_type&,
              const Bottom_type&,
              const Left_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Boundaries (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Boundaries (const Boundaries& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Boundaries*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Boundaries&
  operator= (const Boundaries& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Boundaries ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< BoxSize_type > BoxSize_;
  ::xsd::cxx::tree::one< Front_type > Front_;
  ::xsd::cxx::tree::one< Back_type > Back_;
  ::xsd::cxx::tree::one< Top_type > Top_;
  ::xsd::cxx::tree::one< Right_type > Right_;
  ::xsd::cxx::tree::one< Bottom_type > Bottom_;
  ::xsd::cxx::tree::one< Left_type > Left_;

  //@endcond
};

/**
 * @brief Class corresponding to the %ParallelizationSpecXML schema type.
 *
 * @nosubgrouping
 */
class ParallelizationSpecXML: public ::xml_schema::type
{
  public:
  /**
   * @name numThreads
   *
   * @brief Accessor and modifier functions for the %numThreads
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeInteger numThreads_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< numThreads_type > numThreads_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< numThreads_type, char > numThreads_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const numThreads_optional&
  numThreads () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  numThreads_optional&
  numThreads ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  numThreads (const numThreads_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  numThreads (const numThreads_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  numThreads (::std::unique_ptr< numThreads_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static numThreads_type
  numThreads_default_value ();

  //@}

  /**
   * @name type
   *
   * @brief Accessor and modifier functions for the %type
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string type_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< type_type > type_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const type_optional&
  type () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  type_optional&
  type ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  type (const type_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  type (const type_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  type (::std::unique_ptr< type_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return A read-only (constant) reference to the element's
   * default value.
   */
  static const type_type&
  type_default_value ();

  //@}

  /**
   * @name schedule
   *
   * @brief Accessor and modifier functions for the %schedule
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string schedule_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< schedule_type > schedule_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< schedule_type, char > schedule_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const schedule_optional&
  schedule () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  schedule_optional&
  schedule ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  schedule (const schedule_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  schedule (const schedule_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  schedule (::std::unique_ptr< schedule_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return A read-only (constant) reference to the element's
   * default value.
   */
  static const schedule_type&
  schedule_default_value ();

  //@}

  /**
   * @name chunksize
   *
   * @brief Accessor and modifier functions for the %chunksize
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeInteger chunksize_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< chunksize_type > chunksize_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< chunksize_type, char > chunksize_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const chunksize_optional&
  chunksize () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  chunksize_optional&
  chunksize ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  chunksize (const chunksize_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  chunksize (const chunksize_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  chunksize (::std::unique_ptr< chunksize_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static chunksize_type
  chunksize_default_value ();

  //@}

  /**
   * @name subDomain
   *
   * @brief Accessor and modifier functions for the %subDomain
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::int_3d subDomain_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< subDomain_type > subDomain_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< subDomain_type, char > subDomain_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const subDomain_optional&
  subDomain () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  subDomain_optional&
  subDomain ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  subDomain (const subDomain_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  subDomain (const subDomain_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  subDomain (::std::unique_ptr< subDomain_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  ParallelizationSpecXML ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  ParallelizationSpecXML (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ParallelizationSpecXML (const ParallelizationSpecXML& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual ParallelizationSpecXML*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  ParallelizationSpecXML&
  operator= (const ParallelizationSpecXML& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~ParallelizationSpecXML ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  numThreads_optional numThreads_;
  type_optional type_;
  static const type_type type_default_value_;
  schedule_optional schedule_;
  static const schedule_type schedule_default_value_;
  chunksize_optional chunksize_;
  subDomain_optional subDomain_;

  //@endcond
};

/**
 * @brief Class corresponding to the %Simulation_t schema type.
 *
 * @nosubgrouping
 */
class Simulation_t: public ::xml_schema::type
{
  public:
  /**
   * @name t_end
   *
   * @brief Accessor and modifier functions for the %t_end
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ t_end_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< t_end_type > t_end_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< t_end_type, char, ::xsd::cxx::tree::schema_type::double_ > t_end_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const t_end_optional&
  t_end () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  t_end_optional&
  t_end ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  t_end (const t_end_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  t_end (const t_end_optional& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static t_end_type
  t_end_default_value ();

  //@}

  /**
   * @name delta_t
   *
   * @brief Accessor and modifier functions for the %delta_t
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ delta_t_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< delta_t_type > delta_t_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< delta_t_type, char, ::xsd::cxx::tree::schema_type::double_ > delta_t_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const delta_t_optional&
  delta_t () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  delta_t_optional&
  delta_t ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  delta_t (const delta_t_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  delta_t (const delta_t_optional& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static delta_t_type
  delta_t_default_value ();

  //@}

  /**
   * @name force
   *
   * @brief Accessor and modifier functions for the %force
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ForceType force_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< force_type > force_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< force_type, char > force_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const force_optional&
  force () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  force_optional&
  force ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  force (const force_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  force (const force_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  force (::std::unique_ptr< force_type > p);

  //@}

  /**
   * @name gravity
   *
   * @brief Accessor and modifier functions for the %gravity
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::gravity_t gravity_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< gravity_type > gravity_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< gravity_type, char > gravity_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const gravity_optional&
  gravity () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  gravity_optional&
  gravity ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  gravity (const gravity_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  gravity (const gravity_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  gravity (::std::unique_ptr< gravity_type > p);

  //@}

  /**
   * @name averageVelo
   *
   * @brief Accessor and modifier functions for the %averageVelo
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ averageVelo_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< averageVelo_type > averageVelo_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< averageVelo_type, char, ::xsd::cxx::tree::schema_type::double_ > averageVelo_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const averageVelo_optional&
  averageVelo () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  averageVelo_optional&
  averageVelo ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  averageVelo (const averageVelo_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  averageVelo (const averageVelo_optional& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static averageVelo_type
  averageVelo_default_value ();

  //@}

  /**
   * @name boundaries
   *
   * @brief Accessor and modifier functions for the %boundaries
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Boundaries boundaries_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< boundaries_type > boundaries_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< boundaries_type, char > boundaries_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const boundaries_optional&
  boundaries () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  boundaries_optional&
  boundaries ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  boundaries (const boundaries_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  boundaries (const boundaries_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  boundaries (::std::unique_ptr< boundaries_type > p);

  //@}

  /**
   * @name cutoffRadius
   *
   * @brief Accessor and modifier functions for the %cutoffRadius
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::commonSchema::nonNegativeDouble cutoffRadius_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< cutoffRadius_type > cutoffRadius_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< cutoffRadius_type, char > cutoffRadius_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const cutoffRadius_optional&
  cutoffRadius () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  cutoffRadius_optional&
  cutoffRadius ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  cutoffRadius (const cutoffRadius_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  cutoffRadius (const cutoffRadius_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  cutoffRadius (::std::unique_ptr< cutoffRadius_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static cutoffRadius_type
  cutoffRadius_default_value ();

  //@}

  /**
   * @name thermostat
   *
   * @brief Accessor and modifier functions for the %thermostat
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ThermostatType thermostat_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< thermostat_type > thermostat_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< thermostat_type, char > thermostat_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const thermostat_optional&
  thermostat () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  thermostat_optional&
  thermostat ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  thermostat (const thermostat_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  thermostat (const thermostat_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  thermostat (::std::unique_ptr< thermostat_type > p);

  //@}

  /**
   * @name brownian_motion
   *
   * @brief Accessor and modifier functions for the %brownian_motion
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean brownian_motion_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< brownian_motion_type, char > brownian_motion_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const brownian_motion_type&
  brownian_motion () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  brownian_motion_type&
  brownian_motion ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  brownian_motion (const brownian_motion_type& x);

  //@}

  /**
   * @name cuboid
   *
   * @brief Accessor and modifier functions for the %cuboid
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Cuboid cuboid_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< cuboid_type > cuboid_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef cuboid_sequence::iterator cuboid_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef cuboid_sequence::const_iterator cuboid_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< cuboid_type, char > cuboid_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const cuboid_sequence&
  cuboid () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  cuboid_sequence&
  cuboid ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  cuboid (const cuboid_sequence& s);

  //@}

  /**
   * @name sphere
   *
   * @brief Accessor and modifier functions for the %sphere
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Sphere sphere_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< sphere_type > sphere_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef sphere_sequence::iterator sphere_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef sphere_sequence::const_iterator sphere_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< sphere_type, char > sphere_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const sphere_sequence&
  sphere () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  sphere_sequence&
  sphere ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  sphere (const sphere_sequence& s);

  //@}

  /**
   * @name membrane
   *
   * @brief Accessor and modifier functions for the %membrane
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::Membrane membrane_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< membrane_type > membrane_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef membrane_sequence::iterator membrane_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef membrane_sequence::const_iterator membrane_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< membrane_type, char > membrane_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const membrane_sequence&
  membrane () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  membrane_sequence&
  membrane ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  membrane (const membrane_sequence& s);

  //@}

  /**
   * @name base_name
   *
   * @brief Accessor and modifier functions for the %base_name
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::string base_name_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< base_name_type > base_name_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< base_name_type, char > base_name_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const base_name_optional&
  base_name () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  base_name_optional&
  base_name ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  base_name (const base_name_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  base_name (const base_name_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  base_name (::std::unique_ptr< base_name_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return A read-only (constant) reference to the element's
   * default value.
   */
  static const base_name_type&
  base_name_default_value ();

  //@}

  /**
   * @name writeFrequency
   *
   * @brief Accessor and modifier functions for the %writeFrequency
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ writeFrequency_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< writeFrequency_type > writeFrequency_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< writeFrequency_type, char > writeFrequency_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const writeFrequency_optional&
  writeFrequency () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  writeFrequency_optional&
  writeFrequency ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  writeFrequency (const writeFrequency_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  writeFrequency (const writeFrequency_optional& x);

  //@}

  /**
   * @name log_level
   *
   * @brief Accessor and modifier functions for the %log_level
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::log_level log_level_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< log_level_type > log_level_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< log_level_type, char > log_level_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const log_level_optional&
  log_level () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  log_level_optional&
  log_level ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  log_level (const log_level_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  log_level (const log_level_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  log_level (::std::unique_ptr< log_level_type > p);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static log_level_type
  log_level_default_value ();

  //@}

  /**
   * @name testing_mode
   *
   * @brief Accessor and modifier functions for the %testing_mode
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::boolean testing_mode_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< testing_mode_type > testing_mode_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< testing_mode_type, char > testing_mode_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const testing_mode_optional&
  testing_mode () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  testing_mode_optional&
  testing_mode ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  testing_mode (const testing_mode_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  testing_mode (const testing_mode_optional& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static testing_mode_type
  testing_mode_default_value ();

  //@}

  /**
   * @name parallelization_spec_xml
   *
   * @brief Accessor and modifier functions for the %parallelization_spec_xml
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::ParallelizationSpecXML parallelization_spec_xml_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< parallelization_spec_xml_type > parallelization_spec_xml_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< parallelization_spec_xml_type, char > parallelization_spec_xml_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const parallelization_spec_xml_optional&
  parallelization_spec_xml () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  parallelization_spec_xml_optional&
  parallelization_spec_xml ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  parallelization_spec_xml (const parallelization_spec_xml_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  parallelization_spec_xml (const parallelization_spec_xml_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  parallelization_spec_xml (::std::unique_ptr< parallelization_spec_xml_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  Simulation_t (const brownian_motion_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  Simulation_t (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Simulation_t (const Simulation_t& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual Simulation_t*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  Simulation_t&
  operator= (const Simulation_t& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~Simulation_t ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  t_end_optional t_end_;
  delta_t_optional delta_t_;
  force_optional force_;
  gravity_optional gravity_;
  averageVelo_optional averageVelo_;
  boundaries_optional boundaries_;
  cutoffRadius_optional cutoffRadius_;
  thermostat_optional thermostat_;
  ::xsd::cxx::tree::one< brownian_motion_type > brownian_motion_;
  cuboid_sequence cuboid_;
  sphere_sequence sphere_;
  membrane_sequence membrane_;
  base_name_optional base_name_;
  static const base_name_type base_name_default_value_;
  writeFrequency_optional writeFrequency_;
  log_level_optional log_level_;
  testing_mode_optional testing_mode_;
  parallelization_spec_xml_optional parallelization_spec_xml_;

  //@endcond
};

/**
 * @brief Class corresponding to the %hardcoded_force schema type.
 *
 * @nosubgrouping
 */
class hardcoded_force: public ::xml_schema::type
{
  public:
  /**
   * @name end_time
   *
   * @brief Accessor and modifier functions for the %end_time
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ end_time_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< end_time_type, char, ::xsd::cxx::tree::schema_type::double_ > end_time_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const end_time_type&
  end_time () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  end_time_type&
  end_time ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  end_time (const end_time_type& x);

  /**
   * @brief Return the default value for the element.
   *
   * @return The element's default value.
   */
  static end_time_type
  end_time_default_value ();

  //@}

  /**
   * @name force_factors
   *
   * @brief Accessor and modifier functions for the %force_factors
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::force_factors force_factors_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< force_factors_type, char > force_factors_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const force_factors_type&
  force_factors () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  force_factors_type&
  force_factors ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  force_factors (const force_factors_type& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly
   * instead of making a copy.
   */
  void
  force_factors (::std::unique_ptr< force_factors_type > p);

  //@}

  /**
   * @name particles
   *
   * @brief Accessor and modifier functions for the %particles
   * optional element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::particles particles_type;

  /**
   * @brief Element optional container type.
   */
  typedef ::xsd::cxx::tree::optional< particles_type > particles_optional;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< particles_type, char > particles_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * container.
   *
   * @return A constant reference to the optional container.
   */
  const particles_optional&
  particles () const;

  /**
   * @brief Return a read-write reference to the element container.
   *
   * @return A reference to the optional container.
   */
  particles_optional&
  particles ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  particles (const particles_type& x);

  /**
   * @brief Set the element value.
   *
   * @param x An optional container with the new value to set.
   *
   * If the value is present in @a x then this function makes a copy 
   * of this value and sets it as the new value of the element.
   * Otherwise the element container is set the 'not present' state.
   */
  void
  particles (const particles_optional& x);

  /**
   * @brief Set the element value without copying.
   *
   * @param p A new value to use.
   *
   * This function will try to use the passed value directly instead
   * of making a copy.
   */
  void
  particles (::std::unique_ptr< particles_type > p);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  hardcoded_force (const end_time_type&,
                   const force_factors_type&);

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes
   * (::std::unique_ptr version).
   *
   * This constructor will try to use the passed values directly
   * instead of making copies.
   */
  hardcoded_force (const end_time_type&,
                   ::std::unique_ptr< force_factors_type >);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  hardcoded_force (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  hardcoded_force (const hardcoded_force& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual hardcoded_force*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  hardcoded_force&
  operator= (const hardcoded_force& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~hardcoded_force ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< end_time_type > end_time_;
  ::xsd::cxx::tree::one< force_factors_type > force_factors_;
  particles_optional particles_;

  //@endcond
};

/**
 * @brief Class corresponding to the %force_factors schema type.
 *
 * @nosubgrouping
 */
class force_factors: public ::xml_schema::type
{
  public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ x_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::double_ > x_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const x_type&
  x () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  x_type&
  x ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  x (const x_type& x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::double_ > y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const y_type&
  y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  y_type&
  y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  y (const y_type& x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::double_ z_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::double_ > z_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const z_type&
  z () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  z_type&
  z ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  z (const z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  force_factors (const x_type&,
                 const y_type&,
                 const z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  force_factors (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  force_factors (const force_factors& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual force_factors*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  force_factors&
  operator= (const force_factors& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~force_factors ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;

  //@endcond
};

/**
 * @brief Class corresponding to the %particles schema type.
 *
 * @nosubgrouping
 */
class particles: public ::xml_schema::type
{
  public:
  /**
   * @name indices
   *
   * @brief Accessor and modifier functions for the %indices
   * sequence element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::indices indices_type;

  /**
   * @brief Element sequence container type.
   */
  typedef ::xsd::cxx::tree::sequence< indices_type > indices_sequence;

  /**
   * @brief Element iterator type.
   */
  typedef indices_sequence::iterator indices_iterator;

  /**
   * @brief Element constant iterator type.
   */
  typedef indices_sequence::const_iterator indices_const_iterator;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< indices_type, char > indices_traits;

  /**
   * @brief Return a read-only (constant) reference to the element
   * sequence.
   *
   * @return A constant reference to the sequence container.
   */
  const indices_sequence&
  indices () const;

  /**
   * @brief Return a read-write reference to the element sequence.
   *
   * @return A reference to the sequence container.
   */
  indices_sequence&
  indices ();

  /**
   * @brief Copy elements from a given sequence.
   *
   * @param s A sequence to copy elements from.
   *
   * For each element in @a s this function makes a copy and adds it 
   * to the sequence. Note that this operation completely changes the 
   * sequence and all old elements will be lost.
   */
  void
  indices (const indices_sequence& s);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  particles ();

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  particles (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  particles (const particles& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual particles*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  particles&
  operator= (const particles& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~particles ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  indices_sequence indices_;

  //@endcond
};

/**
 * @brief Class corresponding to the %indices schema type.
 *
 * @nosubgrouping
 */
class indices: public ::xml_schema::type
{
  public:
  /**
   * @name x
   *
   * @brief Accessor and modifier functions for the %x
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ x_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const x_type&
  x () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  x_type&
  x ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  x (const x_type& x);

  //@}

  /**
   * @name y
   *
   * @brief Accessor and modifier functions for the %y
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ y_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const y_type&
  y () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  y_type&
  y ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  y (const y_type& x);

  //@}

  /**
   * @name z
   *
   * @brief Accessor and modifier functions for the %z
   * required element.
   */
  //@{

  /**
   * @brief Element type.
   */
  typedef ::xml_schema::int_ z_type;

  /**
   * @brief Element traits type.
   */
  typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

  /**
   * @brief Return a read-only (constant) reference to the element.
   *
   * @return A constant reference to the element.
   */
  const z_type&
  z () const;

  /**
   * @brief Return a read-write reference to the element.
   *
   * @return A reference to the element.
   */
  z_type&
  z ();

  /**
   * @brief Set the element value.
   *
   * @param x A new value to set.
   *
   * This function makes a copy of its argument and sets it as
   * the new value of the element.
   */
  void
  z (const z_type& x);

  //@}

  /**
   * @name Constructors
   */
  //@{

  /**
   * @brief Create an instance from the ultimate base and
   * initializers for required elements and attributes.
   */
  indices (const x_type&,
           const y_type&,
           const z_type&);

  /**
   * @brief Create an instance from a DOM element.
   *
   * @param e A DOM element to extract the data from.
   * @param f Flags to create the new instance with.
   * @param c A pointer to the object that will contain the new
   * instance.
   */
  indices (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy constructor.
   *
   * @param x An instance to make a copy of.
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  indices (const indices& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  /**
   * @brief Copy the instance polymorphically.
   *
   * @param f Flags to create the copy with.
   * @param c A pointer to the object that will contain the copy.
   * @return A pointer to the dynamically allocated copy.
   *
   * This function ensures that the dynamic type of the instance is
   * used for copying and should be used for polymorphic object
   * models instead of the copy constructor.
   */
  virtual indices*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  /**
   * @brief Copy assignment operator.
   *
   * @param x An instance to make a copy of.
   * @return A reference to itself.
   *
   * For polymorphic object models use the @c _clone function instead.
   */
  indices&
  operator= (const indices& x);

  //@}

  /**
   * @brief Destructor.
   */
  virtual 
  ~indices ();

  // Implementation.
  //

  //@cond

  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< x_type > x_;
  ::xsd::cxx::tree::one< y_type > y_;
  ::xsd::cxx::tree::one< z_type > z_;

  //@endcond
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

/**
 * @name Parsing functions for the %Simulation document root.
 */
//@{

/**
 * @brief Parse a URI or a local file.
 *
 * @param uri A URI or a local file name.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (const ::std::string& uri,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with an error handler.
 *
 * @param uri A URI or a local file name.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (const ::std::string& uri,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a URI or a local file with a Xerces-C++ DOM error
 * handler.
 *
 * @param uri A URI or a local file name.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (const ::std::string& uri,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream.
 *
 * @param is A standrad input stream.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (::std::istream& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with an error handler.
 *
 * @param is A standrad input stream.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (::std::istream& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a Xerces-C++ DOM error
 * handler.
 *
 * @param is A standrad input stream.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (::std::istream& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and an
 * error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (::std::istream& is,
            const ::std::string& id,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a standard input stream with a resource id and a
 * Xerces-C++ DOM error handler.
 *
 * @param is A standrad input stream.
 * @param id A resource id.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * The resource id is used to identify the document being parsed in
 * diagnostics as well as to resolve relative paths.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (::std::istream& is,
            const ::std::string& id,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source.
 *
 * @param is A Xerces-C++ input source.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function uses exceptions to report parsing errors.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (::xercesc::InputSource& is,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with an error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh An error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (::xercesc::InputSource& is,
            ::xml_schema::error_handler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ input source with a Xerces-C++ DOM
 * error handler.
 *
 * @param is A Xerces-C++ input source.
 * @param eh A Xerces-C++ DOM error handler.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function reports parsing errors by calling the error handler.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (::xercesc::InputSource& is,
            ::xercesc::DOMErrorHandler& eh,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (const ::xercesc::DOMDocument& d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

/**
 * @brief Parse a Xerces-C++ DOM document.
 *
 * @param d A pointer to the Xerces-C++ DOM document.
 * @param f Parsing flags.
 * @param p Parsing properties. 
 * @return A pointer to the root of the object model.
 *
 * This function is normally used together with the keep_dom and
 * own_dom parsing flags to assign ownership of the DOM document
 * to the object model.
 */
::std::unique_ptr< ::Simulation_t >
Simulation (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
            ::xml_schema::flags f = 0,
            const ::xml_schema::properties& p = ::xml_schema::properties ());

//@}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_________INPUT_SIMULATION_FORMAT_H
